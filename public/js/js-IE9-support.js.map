{"version":3,"sources":["respond.js","html5shiv.js","sky-forms-ie8.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"js-IE9-support.js","sourcesContent":["\r\n/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas. Dual MIT/BSD license */\r\n/*! NOTE: If you're already including a window.matchMedia polyfill via Modernizr or otherwise, you don't need this part */\r\nwindow.matchMedia = window.matchMedia || (function(doc, undefined){\r\n  \r\n  var bool,\r\n      docElem  = doc.documentElement,\r\n      refNode  = docElem.firstElementChild || docElem.firstChild,\r\n      // fakeBody required for <FF4 when executed in <head>\r\n      fakeBody = doc.createElement('body'),\r\n      div      = doc.createElement('div');\r\n  \r\n  div.id = 'mq-test-1';\r\n  div.style.cssText = \"position:absolute;top:-100em\";\r\n  fakeBody.style.background = \"none\";\r\n  fakeBody.appendChild(div);\r\n  \r\n  return function(q){\r\n    \r\n    div.innerHTML = '&shy;<style media=\"'+q+'\"> #mq-test-1 { width: 42px; }</style>';\r\n    \r\n    docElem.insertBefore(fakeBody, refNode);\r\n    bool = div.offsetWidth == 42;  \r\n    docElem.removeChild(fakeBody);\r\n    \r\n    return { matches: bool, media: q };\r\n  };\r\n  \r\n})(document);\r\n\r\n\r\n\r\n\r\n/*! Respond.js v1.1.0: min/max-width media query polyfill. (c) Scott Jehl. MIT/GPLv2 Lic. j.mp/respondjs  */\r\n(function( win ){\r\n\t//exposed namespace\r\n\twin.respond\t\t= {};\r\n\t\r\n\t//define update even in native-mq-supporting browsers, to avoid errors\r\n\trespond.update\t= function(){};\r\n\t\r\n\t//expose media query support flag for external use\r\n\trespond.mediaQueriesSupported\t= win.matchMedia && win.matchMedia( \"only all\" ).matches;\r\n\t\r\n\t//if media queries are supported, exit here\r\n\tif( respond.mediaQueriesSupported ){ return; }\r\n\t\r\n\t//define vars\r\n\tvar doc \t\t\t= win.document,\r\n\t\tdocElem \t\t= doc.documentElement,\r\n\t\tmediastyles\t\t= [],\r\n\t\trules\t\t\t= [],\r\n\t\tappendedEls \t= [],\r\n\t\tparsedSheets \t= {},\r\n\t\tresizeThrottle\t= 30,\r\n\t\thead \t\t\t= doc.getElementsByTagName( \"head\" )[0] || docElem,\r\n\t\tbase\t\t\t= doc.getElementsByTagName( \"base\" )[0],\r\n\t\tlinks\t\t\t= head.getElementsByTagName( \"link\" ),\r\n\t\trequestQueue\t= [],\r\n\t\t\r\n\t\t//loop stylesheets, send text content to translate\r\n\t\tripCSS\t\t\t= function(){\r\n\t\t\tvar sheets \t= links,\r\n\t\t\t\tsl \t\t= sheets.length,\r\n\t\t\t\ti\t\t= 0,\r\n\t\t\t\t//vars for loop:\r\n\t\t\t\tsheet, href, media, isCSS;\r\n\r\n\t\t\tfor( ; i < sl; i++ ){\r\n\t\t\t\tsheet\t= sheets[ i ],\r\n\t\t\t\thref\t= sheet.href,\r\n\t\t\t\tmedia\t= sheet.media,\r\n\t\t\t\tisCSS\t= sheet.rel && sheet.rel.toLowerCase() === \"stylesheet\";\r\n\r\n\t\t\t\t//only links plz and prevent re-parsing\r\n\t\t\t\tif( !!href && isCSS && !parsedSheets[ href ] ){\r\n\t\t\t\t\t// selectivizr exposes css through the rawCssText expando\r\n\t\t\t\t\tif (sheet.styleSheet && sheet.styleSheet.rawCssText) {\r\n\t\t\t\t\t\ttranslate( sheet.styleSheet.rawCssText, href, media );\r\n\t\t\t\t\t\tparsedSheets[ href ] = true;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif( (!/^([a-zA-Z:]*\\/\\/)/.test( href ) && !base)\r\n\t\t\t\t\t\t\t|| href.replace( RegExp.$1, \"\" ).split( \"/\" )[0] === win.location.host ){\r\n\t\t\t\t\t\t\trequestQueue.push( {\r\n\t\t\t\t\t\t\t\thref: href,\r\n\t\t\t\t\t\t\t\tmedia: media\r\n\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmakeRequests();\r\n\t\t},\r\n\t\t\r\n\t\t//recurse through request queue, get css text\r\n\t\tmakeRequests\t= function(){\r\n\t\t\tif( requestQueue.length ){\r\n\t\t\t\tvar thisRequest = requestQueue.shift();\r\n\t\t\t\t\r\n\t\t\t\tajax( thisRequest.href, function( styles ){\r\n\t\t\t\t\ttranslate( styles, thisRequest.href, thisRequest.media );\r\n\t\t\t\t\tparsedSheets[ thisRequest.href ] = true;\r\n\t\t\t\t\tmakeRequests();\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//find media blocks in css text, convert to style blocks\r\n\t\ttranslate\t\t\t= function( styles, href, media ){\r\n\t\t\tvar qs\t\t\t= styles.match(  /@media[^\\{]+\\{([^\\{\\}]*\\{[^\\}\\{]*\\})+/gi ),\r\n\t\t\t\tql\t\t\t= qs && qs.length || 0,\r\n\t\t\t\t//try to get CSS path\r\n\t\t\t\thref\t\t= href.substring( 0, href.lastIndexOf( \"/\" )),\r\n\t\t\t\trepUrls\t\t= function( css ){\r\n\t\t\t\t\treturn css.replace( /(url\\()['\"]?([^\\/\\)'\"][^:\\)'\"]+)['\"]?(\\))/g, \"$1\" + href + \"$2$3\" );\r\n\t\t\t\t},\r\n\t\t\t\tuseMedia\t= !ql && media,\r\n\t\t\t\t//vars used in loop\r\n\t\t\t\ti\t\t\t= 0,\r\n\t\t\t\tj, fullq, thisq, eachq, eql;\r\n\r\n\t\t\t//if path exists, tack on trailing slash\r\n\t\t\tif( href.length ){ href += \"/\"; }\t\r\n\t\t\t\t\r\n\t\t\t//if no internal queries exist, but media attr does, use that\t\r\n\t\t\t//note: this currently lacks support for situations where a media attr is specified on a link AND\r\n\t\t\t\t//its associated stylesheet has internal CSS media queries.\r\n\t\t\t\t//In those cases, the media attribute will currently be ignored.\r\n\t\t\tif( useMedia ){\r\n\t\t\t\tql = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\r\n\t\t\tfor( ; i < ql; i++ ){\r\n\t\t\t\tj\t= 0;\r\n\t\t\t\t\r\n\t\t\t\t//media attr\r\n\t\t\t\tif( useMedia ){\r\n\t\t\t\t\tfullq = media;\r\n\t\t\t\t\trules.push( repUrls( styles ) );\r\n\t\t\t\t}\r\n\t\t\t\t//parse for styles\r\n\t\t\t\telse{\r\n\t\t\t\t\tfullq\t= qs[ i ].match( /@media *([^\\{]+)\\{([\\S\\s]+?)$/ ) && RegExp.$1;\r\n\t\t\t\t\trules.push( RegExp.$2 && repUrls( RegExp.$2 ) );\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\teachq\t= fullq.split( \",\" );\r\n\t\t\t\teql\t\t= eachq.length;\r\n\t\t\t\t\t\r\n\t\t\t\tfor( ; j < eql; j++ ){\r\n\t\t\t\t\tthisq\t= eachq[ j ];\r\n\t\t\t\t\tmediastyles.push( { \r\n\t\t\t\t\t\tmedia\t: thisq.split( \"(\" )[ 0 ].match( /(only\\s+)?([a-zA-Z]+)\\s?/ ) && RegExp.$2 || \"all\",\r\n\t\t\t\t\t\trules\t: rules.length - 1,\r\n\t\t\t\t\t\thasquery: thisq.indexOf(\"(\") > -1,\r\n\t\t\t\t\t\tminw\t: thisq.match( /\\(min\\-width:[\\s]*([\\s]*[0-9\\.]+)(px|em)[\\s]*\\)/ ) && parseFloat( RegExp.$1 ) + ( RegExp.$2 || \"\" ), \r\n\t\t\t\t\t\tmaxw\t: thisq.match( /\\(max\\-width:[\\s]*([\\s]*[0-9\\.]+)(px|em)[\\s]*\\)/ ) && parseFloat( RegExp.$1 ) + ( RegExp.$2 || \"\" )\r\n\t\t\t\t\t} );\r\n\t\t\t\t}\t\r\n\t\t\t}\r\n\r\n\t\t\tapplyMedia();\r\n\t\t},\r\n        \t\r\n\t\tlastCall,\r\n\t\t\r\n\t\tresizeDefer,\r\n\t\t\r\n\t\t// returns the value of 1em in pixels\r\n\t\tgetEmValue\t\t= function() {\r\n\t\t\tvar ret,\r\n\t\t\t\tdiv = doc.createElement('div'),\r\n\t\t\t\tbody = doc.body,\r\n\t\t\t\tfakeUsed = false;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\tdiv.style.cssText = \"position:absolute;font-size:1em;width:1em\";\r\n\t\t\t\t\t\r\n\t\t\tif( !body ){\r\n\t\t\t\tbody = fakeUsed = doc.createElement( \"body\" );\r\n\t\t\t\tbody.style.background = \"none\";\r\n\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\tbody.appendChild( div );\r\n\t\t\t\t\t\t\t\t\r\n\t\t\tdocElem.insertBefore( body, docElem.firstChild );\r\n\t\t\t\t\t\t\t\t\r\n\t\t\tret = div.offsetWidth;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\tif( fakeUsed ){\r\n\t\t\t\tdocElem.removeChild( body );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbody.removeChild( div );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//also update eminpx before returning\r\n\t\t\tret = eminpx = parseFloat(ret);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\treturn ret;\r\n\t\t},\r\n\t\t\r\n\t\t//cached container for 1em value, populated the first time it's needed \r\n\t\teminpx,\r\n\t\t\r\n\t\t//enable/disable styles\r\n\t\tapplyMedia\t\t\t= function( fromResize ){\r\n\t\t\tvar name\t\t= \"clientWidth\",\r\n\t\t\t\tdocElemProp\t= docElem[ name ],\r\n\t\t\t\tcurrWidth \t= doc.compatMode === \"CSS1Compat\" && docElemProp || doc.body[ name ] || docElemProp,\r\n\t\t\t\tstyleBlocks\t= {},\r\n\t\t\t\tlastLink\t= links[ links.length-1 ],\r\n\t\t\t\tnow \t\t= (new Date()).getTime();\r\n\r\n\t\t\t//throttle resize calls\t\r\n\t\t\tif( fromResize && lastCall && now - lastCall < resizeThrottle ){\r\n\t\t\t\tclearTimeout( resizeDefer );\r\n\t\t\t\tresizeDefer = setTimeout( applyMedia, resizeThrottle );\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlastCall\t= now;\r\n\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\tfor( var i in mediastyles ){\r\n\t\t\t\tvar thisstyle = mediastyles[ i ],\r\n\t\t\t\t\tmin = thisstyle.minw,\r\n\t\t\t\t\tmax = thisstyle.maxw,\r\n\t\t\t\t\tminnull = min === null,\r\n\t\t\t\t\tmaxnull = max === null,\r\n\t\t\t\t\tem = \"em\";\r\n\t\t\t\t\r\n\t\t\t\tif( !!min ){\r\n\t\t\t\t\tmin = parseFloat( min ) * ( min.indexOf( em ) > -1 ? ( eminpx || getEmValue() ) : 1 );\r\n\t\t\t\t}\r\n\t\t\t\tif( !!max ){\r\n\t\t\t\t\tmax = parseFloat( max ) * ( max.indexOf( em ) > -1 ? ( eminpx || getEmValue() ) : 1 );\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// if there's no media query at all (the () part), or min or max is not null, and if either is present, they're true\r\n\t\t\t\tif( !thisstyle.hasquery || ( !minnull || !maxnull ) && ( minnull || currWidth >= min ) && ( maxnull || currWidth <= max ) ){\r\n\t\t\t\t\t\tif( !styleBlocks[ thisstyle.media ] ){\r\n\t\t\t\t\t\t\tstyleBlocks[ thisstyle.media ] = [];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstyleBlocks[ thisstyle.media ].push( rules[ thisstyle.rules ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//remove any existing respond style element(s)\r\n\t\t\tfor( var i in appendedEls ){\r\n\t\t\t\tif( appendedEls[ i ] && appendedEls[ i ].parentNode === head ){\r\n\t\t\t\t\thead.removeChild( appendedEls[ i ] );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//inject active styles, grouped by media type\r\n\t\t\tfor( var i in styleBlocks ){\r\n\t\t\t\tvar ss\t\t= doc.createElement( \"style\" ),\r\n\t\t\t\t\tcss\t\t= styleBlocks[ i ].join( \"\\n\" );\r\n\t\t\t\t\r\n\t\t\t\tss.type = \"text/css\";\t\r\n\t\t\t\tss.media\t= i;\r\n\t\t\t\t\r\n\t\t\t\t//originally, ss was appended to a documentFragment and sheets were appended in bulk.\r\n\t\t\t\t//this caused crashes in IE in a number of circumstances, such as when the HTML element had a bg image set, so appending beforehand seems best. Thanks to @dvelyk for the initial research on this one!\r\n\t\t\t\thead.insertBefore( ss, lastLink.nextSibling );\r\n\t\t\t\t\r\n\t\t\t\tif ( ss.styleSheet ){ \r\n\t\t        \tss.styleSheet.cssText = css;\r\n\t\t        } \r\n\t\t        else {\r\n\t\t\t\t\tss.appendChild( doc.createTextNode( css ) );\r\n\t\t        }\r\n\t\t        \r\n\t\t\t\t//push to appendedEls to track for later removal\r\n\t\t\t\tappendedEls.push( ss );\r\n\t\t\t}\r\n\t\t},\r\n\t\t//tweaked Ajax functions from Quirksmode\r\n\t\tajax = function( url, callback ) {\r\n\t\t\tvar req = xmlHttp();\r\n\t\t\tif (!req){\r\n\t\t\t\treturn;\r\n\t\t\t}\t\r\n\t\t\treq.open( \"GET\", url, true );\r\n\t\t\treq.onreadystatechange = function () {\r\n\t\t\t\tif ( req.readyState != 4 || req.status != 200 && req.status != 304 ){\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tcallback( req.responseText );\r\n\t\t\t}\r\n\t\t\tif ( req.readyState == 4 ){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\treq.send( null );\r\n\t\t},\r\n\t\t//define ajax obj \r\n\t\txmlHttp = (function() {\r\n\t\t\tvar xmlhttpmethod = false;\t\r\n\t\t\ttry {\r\n\t\t\t\txmlhttpmethod = new XMLHttpRequest();\r\n\t\t\t}\r\n\t\t\tcatch( e ){\r\n\t\t\t\txmlhttpmethod = new ActiveXObject( \"Microsoft.XMLHTTP\" );\r\n\t\t\t}\r\n\t\t\treturn function(){\r\n\t\t\t\treturn xmlhttpmethod;\r\n\t\t\t};\r\n\t\t})();\r\n\t\r\n\t//translate CSS\r\n\tripCSS();\r\n\t\r\n\t//expose update for re-running respond later on\r\n\trespond.update = ripCSS;\r\n\t\r\n\t//adjust on resize\r\n\tfunction callMedia(){\r\n\t\tapplyMedia( true );\r\n\t}\r\n\tif( win.addEventListener ){\r\n\t\twin.addEventListener( \"resize\", callMedia, false );\r\n\t}\r\n\telse if( win.attachEvent ){\r\n\t\twin.attachEvent( \"onresize\", callMedia );\r\n\t}\r\n})(this);","/**\n* @preserve HTML5 Shiv 3.7.2 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed\n*/\n;(function(window, document) {\n/*jshint evil:true */\n  /** version */\n  var version = '3.7.2';\n\n  /** Preset options */\n  var options = window.html5 || {};\n\n  /** Used to skip problem elements */\n  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;\n\n  /** Not all elements can be cloned in IE **/\n  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;\n\n  /** Detect whether the browser supports default html5 styles */\n  var supportsHtml5Styles;\n\n  /** Name of the expando, to work with multiple documents or to re-shiv one document */\n  var expando = '_html5shiv';\n\n  /** The id for the the documents expando */\n  var expanID = 0;\n\n  /** Cached data for each document */\n  var expandoData = {};\n\n  /** Detect whether the browser supports unknown elements */\n  var supportsUnknownElements;\n\n  (function() {\n    try {\n        var a = document.createElement('a');\n        a.innerHTML = '<xyz></xyz>';\n        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles\n        supportsHtml5Styles = ('hidden' in a);\n\n        supportsUnknownElements = a.childNodes.length == 1 || (function() {\n          // assign a false positive if unable to shiv\n          (document.createElement)('a');\n          var frag = document.createDocumentFragment();\n          return (\n            typeof frag.cloneNode == 'undefined' ||\n            typeof frag.createDocumentFragment == 'undefined' ||\n            typeof frag.createElement == 'undefined'\n          );\n        }());\n    } catch(e) {\n      // assign a false positive if detection fails => unable to shiv\n      supportsHtml5Styles = true;\n      supportsUnknownElements = true;\n    }\n\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates a style sheet with the given CSS text and adds it to the document.\n   * @private\n   * @param {Document} ownerDocument The document.\n   * @param {String} cssText The CSS text.\n   * @returns {StyleSheet} The style element.\n   */\n  function addStyleSheet(ownerDocument, cssText) {\n    var p = ownerDocument.createElement('p'),\n        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;\n\n    p.innerHTML = 'x<style>' + cssText + '</style>';\n    return parent.insertBefore(p.lastChild, parent.firstChild);\n  }\n\n  /**\n   * Returns the value of `html5.elements` as an array.\n   * @private\n   * @returns {Array} An array of shived element node names.\n   */\n  function getElements() {\n    var elements = html5.elements;\n    return typeof elements == 'string' ? elements.split(' ') : elements;\n  }\n\n  /**\n   * Extends the built-in list of html5 elements\n   * @memberOf html5\n   * @param {String|Array} newElements whitespace separated list or array of new element names to shiv\n   * @param {Document} ownerDocument The context document.\n   */\n  function addElements(newElements, ownerDocument) {\n    var elements = html5.elements;\n    if(typeof elements != 'string'){\n      elements = elements.join(' ');\n    }\n    if(typeof newElements != 'string'){\n      newElements = newElements.join(' ');\n    }\n    html5.elements = elements +' '+ newElements;\n    shivDocument(ownerDocument);\n  }\n\n   /**\n   * Returns the data associated to the given document\n   * @private\n   * @param {Document} ownerDocument The document.\n   * @returns {Object} An object of data.\n   */\n  function getExpandoData(ownerDocument) {\n    var data = expandoData[ownerDocument[expando]];\n    if (!data) {\n        data = {};\n        expanID++;\n        ownerDocument[expando] = expanID;\n        expandoData[expanID] = data;\n    }\n    return data;\n  }\n\n  /**\n   * returns a shived element for the given nodeName and document\n   * @memberOf html5\n   * @param {String} nodeName name of the element\n   * @param {Document} ownerDocument The context document.\n   * @returns {Object} The shived element.\n   */\n  function createElement(nodeName, ownerDocument, data){\n    if (!ownerDocument) {\n        ownerDocument = document;\n    }\n    if(supportsUnknownElements){\n        return ownerDocument.createElement(nodeName);\n    }\n    if (!data) {\n        data = getExpandoData(ownerDocument);\n    }\n    var node;\n\n    if (data.cache[nodeName]) {\n        node = data.cache[nodeName].cloneNode();\n    } else if (saveClones.test(nodeName)) {\n        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();\n    } else {\n        node = data.createElem(nodeName);\n    }\n\n    // Avoid adding some elements to fragments in IE < 9 because\n    // * Attributes like `name` or `type` cannot be set/changed once an element\n    //   is inserted into a document/fragment\n    // * Link elements with `src` attributes that are inaccessible, as with\n    //   a 403 response, will cause the tab/window to crash\n    // * Script elements appended to fragments will execute when their `src`\n    //   or `text` property is set\n    return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;\n  }\n\n  /**\n   * returns a shived DocumentFragment for the given document\n   * @memberOf html5\n   * @param {Document} ownerDocument The context document.\n   * @returns {Object} The shived DocumentFragment.\n   */\n  function createDocumentFragment(ownerDocument, data){\n    if (!ownerDocument) {\n        ownerDocument = document;\n    }\n    if(supportsUnknownElements){\n        return ownerDocument.createDocumentFragment();\n    }\n    data = data || getExpandoData(ownerDocument);\n    var clone = data.frag.cloneNode(),\n        i = 0,\n        elems = getElements(),\n        l = elems.length;\n    for(;i<l;i++){\n        clone.createElement(elems[i]);\n    }\n    return clone;\n  }\n\n  /**\n   * Shivs the `createElement` and `createDocumentFragment` methods of the document.\n   * @private\n   * @param {Document|DocumentFragment} ownerDocument The document.\n   * @param {Object} data of the document.\n   */\n  function shivMethods(ownerDocument, data) {\n    if (!data.cache) {\n        data.cache = {};\n        data.createElem = ownerDocument.createElement;\n        data.createFrag = ownerDocument.createDocumentFragment;\n        data.frag = data.createFrag();\n    }\n\n\n    ownerDocument.createElement = function(nodeName) {\n      //abort shiv\n      if (!html5.shivMethods) {\n          return data.createElem(nodeName);\n      }\n      return createElement(nodeName, ownerDocument, data);\n    };\n\n    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +\n      'var n=f.cloneNode(),c=n.createElement;' +\n      'h.shivMethods&&(' +\n        // unroll the `createElement` calls\n        getElements().join().replace(/[\\w\\-:]+/g, function(nodeName) {\n          data.createElem(nodeName);\n          data.frag.createElement(nodeName);\n          return 'c(\"' + nodeName + '\")';\n        }) +\n      ');return n}'\n    )(html5, data.frag);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Shivs the given document.\n   * @memberOf html5\n   * @param {Document} ownerDocument The document to shiv.\n   * @returns {Document} The shived document.\n   */\n  function shivDocument(ownerDocument) {\n    if (!ownerDocument) {\n        ownerDocument = document;\n    }\n    var data = getExpandoData(ownerDocument);\n\n    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {\n      data.hasCSS = !!addStyleSheet(ownerDocument,\n        // corrects block display not defined in IE6/7/8/9\n        'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +\n        // adds styling not present in IE6/7/8/9\n        'mark{background:#FF0;color:#000}' +\n        // hides non-rendered elements\n        'template{display:none}'\n      );\n    }\n    if (!supportsUnknownElements) {\n      shivMethods(ownerDocument, data);\n    }\n    return ownerDocument;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The `html5` object is exposed so that more elements can be shived and\n   * existing shiving can be detected on iframes.\n   * @type Object\n   * @example\n   *\n   * // options can be changed before the script is included\n   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };\n   */\n  var html5 = {\n\n    /**\n     * An array or space separated string of node names of the elements to shiv.\n     * @memberOf html5\n     * @type Array|String\n     */\n    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',\n\n    /**\n     * current version of html5shiv\n     */\n    'version': version,\n\n    /**\n     * A flag to indicate that the HTML5 style sheet should be inserted.\n     * @memberOf html5\n     * @type Boolean\n     */\n    'shivCSS': (options.shivCSS !== false),\n\n    /**\n     * Is equal to true if a browser supports creating unknown/HTML5 elements\n     * @memberOf html5\n     * @type boolean\n     */\n    'supportsUnknownElements': supportsUnknownElements,\n\n    /**\n     * A flag to indicate that the document's `createElement` and `createDocumentFragment`\n     * methods should be overwritten.\n     * @memberOf html5\n     * @type Boolean\n     */\n    'shivMethods': (options.shivMethods !== false),\n\n    /**\n     * A string to describe the type of `html5` object (\"default\" or \"default print\").\n     * @memberOf html5\n     * @type String\n     */\n    'type': 'default',\n\n    // shivs the document according to the specified `html5` object options\n    'shivDocument': shivDocument,\n\n    //creates a shived element\n    createElement: createElement,\n\n    //creates a shived documentFragment\n    createDocumentFragment: createDocumentFragment,\n\n    //extends list of elements\n    addElements: addElements\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose html5\n  window.html5 = html5;\n\n  // shiv the document\n  shivDocument(document);\n\n}(this, document));\n","$(function()\n{\n\t$('input[type=\"checkbox\"]:checked, input[type=\"radio\"]:checked').addClass('checked');\n\t\n\t$('.sky-form').on('change', 'input[type=\"radio\"]', function()\n\t{\n\t\t$(this).closest('.sky-form').find('input[name=\"' + $(this).attr('name') + '\"]').removeClass('checked');\n\t\t$(this).addClass('checked');\n\t});\n\t\n\t$('.sky-form').on('change', 'input[type=\"checkbox\"]', function()\n\t{\n\t\t$(this).toggleClass('checked');\n\t});\n});"],"sourceRoot":"/source/"}